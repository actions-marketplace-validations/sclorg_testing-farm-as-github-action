name: 'Schedule tests on Testing Farm'
description: 'A GitHub action will schedule a user defined tests to the Testing Farm to run tmt tests.'
author: 'RHSCL team'
branding:
  icon: circle
  color: red

inputs:
  api_url:
    description: 'A testing farm server url'
    required: true
    default: 'https://api.dev.testing-farm.io/v0.1'
  api_key:
    description: 'A testing farm API key'
    required: true
  tmt_repository:
    description: 'An url to tmt repository'
    required: true
  github_token:
    description: 'A github token passed from secrets'
    required: true
  test_fmf_plan:
    required: false
    description: 'A fmf plan which will be selected. By default all plans are selected.'
  tests_tmt_ref:
    description: 'A tmt tests branch which will be used for tests'
    required: false
    default: 'master'
  compose:
    description: 'A compose for tests'
    default: 'Fedora'
    required: true
  create_issue_comment:
    description: 'It creates a github issue Comment'
    required: false
    default: 'false'
  pull_request_status_name:
    description: 'GitHub pull request status name'
    required: false
    default: 'Fedora'
  env_vars:
    description: 'Environment variables for test env, separated by ;'
    required: false
    default: ''
  env_secrets:
    description: 'Environment secrets for test env, separated by ;'
    required: false
    default: ''
  debug:
    description: 'Print debug logs when working with testing farm'
    required: false
    default: 'true'
  update_pull_request_status:
    description: 'Action will update pull request status. Default: true'
    required: false
    default: 'true'
  arch:
    description: 'Define an architecture for testing environment. Default: x86_64'
    required: false
    default: 'x86_64'
  copr:
    description: 'Name of copr to use for the artifacts'
    required: false
    default: 'epel-7-x86_64'
  test_artifacts:
    description: '"fedora-copr-build" artifacts for testing environment. Separated by ;'
    required: false
    default: ''
  tmt_context:
    description: 'A value of tmt.context variable https://tmt.readthedocs.io/en/latest/spec/context.html, variables separated by ;'
    required: false
    default: ''
  artifacts_url:
    description: 'Baseurl where results can be found'
    required: false
    default: 'http://artifacts.osci.redhat.com/testing-farm'
outputs:
  request_id:
    description: 'An ID of a scheduled testing farm request'
    value: ${{ env.REQ_ID }}
  request_url:
    description: 'An url of a scheduled testing farm request'
    value: ${{ env.RESULTS_URL }}
runs:
  using: "composite"
  steps:
    - name: Install mandatory packages
      run: |
        sudo apt update && sudo apt -y install curl jq
      shell: bash

    - name: Get pull request number
      id: pr_nr
      run: |
        PR_URL="${{ github.event.comment.issue_url }}"
        echo "::set-output name=PR_NR::${PR_URL##*/}"
      shell: bash

    - name: Get commit SHA value
      id: sha_value
      run: |
        echo "::set-output name=SHA::$(git rev-parse HEAD)"
      shell: bash

    - name: Generate tmt variables
      id: generate_tmt_vars
      run: |
        python -c 'import json; print({} if not "${{ inputs.env_vars }}".strip() else json.dumps({key: value for key, value in [s.split("=", 1) for s in "${{ inputs.env_vars }}".split(";")]}))' > env_vars
        echo "::set-output name=TMT_ENV_VARS::$(cat env_vars)"
      shell: bash

    - name: Generate tmt secrets
      id: generate_tmt_secrets
      run: |
        python -c 'import json; print({} if not "${{ inputs.env_secrets }}".strip() else json.dumps({key: value for key, value in [s.split("=", 1) for s in "${{ inputs.env_secrets }}".split(";")]}))' > env_secrets
        echo "::set-output name=TMT_ENV_SECRETS::$(cat env_secrets)"
      shell: bash

    - name: Generate tmt artifacts
      id: generate_tmt_artifacts
      run: |
        python -c 'import json;print(json.dumps(([{"type": "fedora-copr-build", "id": "{}:${{ inputs.copr }}".format(copr_id)} for copr_id in "${{ inputs.test_artifacts }}".split(";")])))' > artifacts
        echo "::set-output name=TMT_ENV_ARTIFACTS::$(cat artifacts)"
      shell: bash

    - name: Generate tmt context
      id: generate_tmt_context
      run: |
        python -c 'import json; print({} if not "${{ inputs.tmt_context }}".strip() else json.dumps({key: value for key, value in [s.split("=", 1) for s in "${{ inputs.tmt_context }}".split(";")]}))' > tmt_context
        echo "::set-output name=TMT_CONTEXT::$(cat tmt_context)"
      shell: bash

    - name: Schedule a test on Testing Farm
      id: sched_test
      run: |
        cat << EOF > request.json
        {
          "api_key": "${{ inputs.api_key }}",
          "test": { "fmf": {
              "url": "${{ inputs.tmt_repository }}",
              "ref": "${{ inputs.tests_tmt_ref }}",
              "name": "${{ inputs.test_fmf_plan }}"
            }
          },
          "environments": [{
            "arch": "${{ inputs.arch }}",
            "os": {
              "compose": "${{ inputs.compose }}"
            },
            "variables": ${{ steps.generate_tmt_vars.outputs.TMT_ENV_VARS }},
            "secrets": ${{ steps.generate_tmt_secrets.outputs.TMT_ENV_SECRETS }},
            "artifacts": ${{ steps.generate_tmt_artifacts.outputs.TMT_ENV_ARTIFACTS }},
            "tmt": {
              "context": ${{ steps.generate_tmt_context.outputs.TMT_CONTEXT }}
            }
          }]
        }
        EOF
        if [ "${{ inputs.debug }}" == "true" ]; then
          echo "Let's print request.json"
          cat request.json
        fi
        curl ${{ inputs.api_url }}/requests \
            --data @request.json \
            --header "Content-Type: application/json" \
            --output response.json

        if [ "${{ inputs.debug }}" == "true" ]; then
          echo "Let's print testing farm response"
          cat response.json
          jq < response.json
        fi

        # Store REQ_ID into GITHUB_ENV variables
        req_id=$(jq -r .id response.json)
        tf_url=$(jq -r .run.artifacts response.json)
        echo "REQ_ID=$req_id" >> $GITHUB_ENV
        # NOTE(ivasilev) Target url may not be available at this moment if the job is still queued, so
        # will rather construct one from artifact_url and id as it has predictable format
        echo "RESULTS_URL=${{ inputs.artifacts_url }}/$req_id" >> $GITHUB_ENV
      shell: bash

    - name: Switch pull request state to running
      id: running
      if: ${{ inputs.update_pull_request_status == 'true' }}
      run: |
        # Create running.json file for query, whether job is finished or not.
        cat << EOF > running.json
        {
          "sha": "${{ steps.sha_value.outputs.SHA }}",
          "state": "pending",
          "context": "Testing Farm - ${{ inputs.pull_request_status_name }}",
          "description": "Build started",
          "target_url": "${{ env.RESULTS_URL }}"
        }
        EOF
        # Update GitHub status description to 'Build started'
        curl -X POST -H "Authorization: Bearer ${{ inputs.github_token }}" -H "Accept: application/vnd.github.v3+json" \
          https://api.github.com/repos/$GITHUB_REPOSITORY/statuses/${{ steps.sha_value.outputs.SHA }} \
          --data @running.json
      shell: bash

    - name: Check if scheduled test is still running
      id: still_running
      if: ${{ inputs.update_pull_request_status == 'true'}}
      run: |
        CMD=${{ inputs.api_url }}/requests/${{ env.REQ_ID }}
        curl $CMD > job.json
        if [ "${{ inputs.debug }}" == "true" ]; then
          cat job.json
          jq < job.json
        fi
        state=$(jq -r .state job.json)
        while [ "$state" == "running" ] || [ "$state" == "new" ] || [ "$state" == "pending" ] || [ "$state" == "queued" ]; do
          sleep 30
          curl $CMD > job.json
          if [ "${{ inputs.debug }}" == "true" ]; then
            cat job.json
            jq < job.json
          fi
          state=$(jq -r .state job.json)
        done
      shell: bash

    - name: Get final state of Testing Farm scheduled request
      id: finale_state
      if: ${{ inputs.update_pull_request_status == 'true'}}
      run: |
        curl ${{ inputs.api_url }}/requests/${{ env.REQ_ID }} > job.json
        if [ "${{ inputs.debug }}" == "true" ]; then
          cat job.json
          jq < job.json
        fi
        state=$(jq -r .state job.json)
        result=$(jq -r .result.overall job.json)
        new_state="success"
        infra_error=" "
        echo "State is $state and result is: $result"
        if [ "$state" == "complete" ]; then
          if [ "$result" != "passed" ]; then
            new_state="failure"
          fi
        else
          # Mark job in case of infrastructure issues. Report to Testing Farm team
          infra_error=" - Infra problems"
          new_state="failure"
        fi
        echo "New State is: $new_state"
        echo "Infra state is: $infra_error"
        echo "::set-output name=FINAL_STATE::$new_state"
        echo "::set-output name=INFRA_STATE::$infra_error"
      shell: bash

    - name: Switch pull request GitHub status to final state
      if: ${{ inputs.update_pull_request_status == 'true' }}
      run: |
        cat << EOF > final.json
        {
          "sha": "${{ steps.sha_value.outputs.SHA }}",
          "state": "${{ steps.final_state.outputs.FINAL_STATE }}",
          "context": "Testing Farm - ${{ inputs.pull_request_status_name }}",
          "description": "Build finished${{ steps.final_state.outputs.INFRA_STATE }}",
          "target_url": "${{ env.RESULTS_URL }}"
        }
        EOF
        if [ "${{ inputs.debug }}" == "true" ]; then
          cat final.json
        fi
        # Switch Github status to proper state
        curl -X POST -H "Authorization:
        Bearer ${{ inputs.github_token }}" -H "Accept: application/vnd.github.v3+json" \
        https://api.github.com/repos/$GITHUB_REPOSITORY/statuses/${{ steps.sha_value.outputs.SHA }} \
        --data @final.json
      shell: bash

    - name: Add comment with Testing Farm request/result to Pull Request
      if: ${{ inputs.create_issue_comment == 'true' }}
      id: github_comment
      uses: actions/github-script@v4
      with:
        script: |
          github.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: 'Testing Farm [request](${{ inputs.api_url }}/requests/${{ env.REQ_ID }})' +
                  ' for ${{ inputs.compose }}/${{ inputs.test_artifacts }} regression testing has been created. Once finished, results should be available' +
                  ' [here](${{ env.RESULTS_URL }}/).' +
                  '\n[Full pipeline log](${{ env.RESULTS_URL }}/pipeline.log).'
          })
